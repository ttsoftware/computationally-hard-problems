\documentclass[12pt]{article}
\usepackage[a4paper, hmargin={2.5cm, 2.5cm}, vmargin={2.5cm, 2.5cm}]{geometry}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes, shadows, arrows, automata}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{float}
\usepackage[english]{varioref}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{etoolbox}
\usepackage{tikz}

\usepackage{fancyhdr}

\setlength\parindent{0pt}
\usepackage[parfill]{parskip}

\definecolor{mygray}{rgb}{0.9451,0.9451,0.9451}
\lstset{
  backgroundcolor=\color{mygray},
  basicstyle=\footnotesize\ttfamily,
  mathescape,
  breaklines=true,
  numbers=left,
  numberstyle=\ttfamily,
  stepnumber=1,
  firstnumber=1,
  numberfirstline=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
  literate={->}{$\rightarrow$}{2}
           {Îµ}{$\varepsilon$}{1}
}

\linespread{1.3}

\title{
  \vspace{4cm}
  \begin{flushleft}
  \Large{\textbf{Mandatory Project 1}} \\
  \large{Computationally hard problems}
  \end{flushleft}
  \vspace{0cm}
  \begin{flushleft}
  \small
  \textit{\today}
  \end{flushleft}
  \vspace{12cm}
  \begin{flushleft}
  \small
  Troels Thomsen \texttt{152165} \\
  Rasmus Haarslev \texttt{152175}
  \end{flushleft}
}

\date{
	%
}

\begin{document}

\clearpage
\pagenumbering{gobble}
\thispagestyle{empty}
\maketitle

\newpage

\pagenumbering{arabic}

\section{Madragon}

\subsection{Determine whether the answer to the given Madragon instance is YES
or NO}
\label{sub:Determine whether the answer to the given Madragon instance is YES
or NO}

We take the following steps to shift the starting board to the goal board.

\textbf{Starting board}:

\begin{tikzpicture}
    \draw[step=1cm,black,thick] (0,0) grid (5,5);
    \fill[black] (0,0) rectangle (5,5);
    % col 1
    \fill[white] (0,3) rectangle (1,4);
    \fill[white] (0,2) rectangle (1,3);
    \fill[white] (0,1) rectangle (1,2);
    % col 2
    \fill[white] (1,3) rectangle (2,4);
    \fill[white] (1,1) rectangle (2,2);
    % col 3
    \fill[white] (2,4) rectangle (3,5);
    \fill[white] (2,2) rectangle (3,3);
    % col 4
    \fill[white] (3,3) rectangle (4,4);
    \fill[white] (3,1) rectangle (4,2);
\end{tikzpicture}

We move column 1 one tile up.

\begin{tikzpicture}
    \draw[step=1cm,black,thick] (0,0) grid (5,5);
    \fill[black] (0,0) rectangle (5,5);
    % col 1
    \fill[white] (0,4) rectangle (1,5);
    \fill[white] (0,3) rectangle (1,4);
    \fill[white] (0,2) rectangle (1,3);
    % col 2
    \fill[white] (1,3) rectangle (2,4);
    \fill[white] (1,1) rectangle (2,2);
    % col 3
    \fill[white] (2,4) rectangle (3,5);
    \fill[white] (2,2) rectangle (3,3);
    % col 4
    \fill[white] (3,3) rectangle (4,4);
    \fill[white] (3,1) rectangle (4,2);
\end{tikzpicture}

We column 2 two tiles down.

\begin{tikzpicture}
    \draw[step=1cm,black,very thick] (0,0) grid (5,5);
    \fill[black] (0,0) rectangle (5,5);
    % col 1
    \fill[white] (0,4) rectangle (1,5);
    \fill[white] (0,3) rectangle (1,4);
    \fill[white] (0,2) rectangle (1,3);
    % col 2
    \fill[white] (1,1) rectangle (2,2);
    \fill[white] (1,4) rectangle (2,5);
    % col 3
    \fill[white] (2,4) rectangle (3,5);
    \fill[white] (2,2) rectangle (3,3);
    % col 4
    \fill[white] (3,3) rectangle (4,4);
    \fill[white] (3,1) rectangle (4,2);
\end{tikzpicture}

We move row 3 two tiles to the left.

\begin{tikzpicture}
    \draw[step=1cm,black,very thick] (0,0) grid (5,5);
    \fill[black] (0,0) rectangle (5,5);
    % col 1
    \fill[white] (0,4) rectangle (1,5);
    \fill[white] (0,3) rectangle (1,4);
    \fill[white] (0,2) rectangle (1,3);
    % col 2
    \fill[white] (1,1) rectangle (2,2);
    \fill[white] (1,4) rectangle (2,5);
    % col 3
    \fill[white] (2,4) rectangle (3,5);
    \fill[white] (3,2) rectangle (4,3);
    % col 4
    \fill[white] (3,3) rectangle (4,4);
    \fill[white] (3,1) rectangle (4,2);
\end{tikzpicture}

And now we have made $k = 3$ operations and achieved the goal.

\subsection{Show that Madragon is in $NP$}
\label{sub:Show that Madragon is in $NP$}

We specify the following randomized deterministic polynomial-bound algorithm $A$, which takes as input a problem instance $X$ containing board states $a$ and $b$ and a random sequence of integers $R$.

\begin{enumerate}
    \item
        \begin{enumerate}
            \item[1a] $R$ is a random sequence of $k$ integers chosen from an even distribution of numbers ranging from 1 to $(m+n)^2$.
            \item[1b] Every index in $R$ corresponds a step. The value of each index corresponds to a move of either a column or a row. Since there exists $(m+n)^2$ unique moves, the value of $R_i$ will determine which of these moves the algorithm performs at the $i$th step.
            \item[1c] After $A$ has performed all $i$ steps in $R$, $A$ checks if the board has reached its goal state $b$ and answers YES or NO accordingly.
        \end{enumerate}
    \item
        \begin{enumerate}
            \item[2a] Since we choose $R$ from an evenly distributed set of all possible combinations of size $\{1, \cdots, (m+n)^2\}^k = (m+n)^{2k}$, we know that if at least one $R$ exists which solves $A(X, R) = YES$, we can choose this $R$ with a probability of $\frac{1}{(m+n)^{2k}} > 0$.
            \item[2b] If there does not exist an $R$ which solves $A(X, R) = YES$, then the algorithm $A$ will never answer YES since the board cannot arrive at goal board $b$ within $k$ steps given any $R$.
        \end{enumerate}
    \item
        In order to interpret $R$ the algorithm $A$ must generate all possible moves for the given board. This can be done in $O((m+n)^2)$ time. We can perform all steps in $R$ in $O(k)$ time, and check the solution in $O(1)$ time.
        Thus the algorithm is bound by $O((m+n)^2)$.
\end{enumerate}

\subsection{Show that Madragon is $NP$-complete}
\label{sub:Show that Madragon is $NP$-complete}

\subsection{Describe the solution for the optimization version of the algorithm}
\label{sub:Describe the solution for the optimization version of the algorithm}

Our solution assumes, that for any given board $A$, there exists a set of moves $R_0$, such that $A$ may be transformed into any board $B$, where $A$ and $B$ consists of the same number of black and white tiles.

For our optimization algorithm, we utilize the decision algorithm for the problem $A_d$, where given a board $A$, a goal board $B$, and a $k$, the algorithm determines whether it is possible to transform $A$ into $B$, using $k$ moves.

$A_d$ takes the set of possible moves $S = \{s_0, s_1, ...,s_n\}$ and creates a set $R = \{R_0, R_1, ..., R_m\}$, containing every combination of $k$ moves from $S$. As there exist $n$ such moves, we will have $m = n^k$.

If one of these sets will transform board $A$ into goal board $B$, then the algorithm returns YES, else NO.

$A_o$ starts by finding the lowest possible $k$. It does this by feeding increasingly larger $k$ to $A_d$, starting at $1$. When $A_d$ returns YES, we have found the lowest number of moves, that transforms $A$ to $B$. In order to find the moves used to make this optimized transformation, we modify $A_d$ to also return the set of moves $R_0$, that made $A_d$ return YES. $R_0$ in this case will be the set containing the minimum number of moves, that transforms $A$ into $B$.

\subsection{Prove the worst-case running time of your algorithm}
\label{sub:Prove the worst-case running time of your algorithm}

The running time for $A_o$ is entirely dependant on the running time of $A_d$, as $A_o$ simply calls $A_d$ multiple times to find the optimal solution.

In the worst case, $A_d$ creates $m = n^k$ sets, where each set can be created and checked in constant time. This gives $A_d$ a worst-case running time of $T(A_d) = O(n^k)$.

$A_o$ calls $A_d$ until it has found the optimal value of $k$, which takes $k$ calls. When $k$, and thus the solution $R_0$ has been found, the algorithm terminates, which gives us a running time of $T(A_o) = O(k T(A_d)) = O(kn^k)$

\subsection{implement the algorithm for Madragon}
\label{sub:implement the algorithm for Madragon}



\end{document}
